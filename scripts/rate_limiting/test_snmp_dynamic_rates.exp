#!/usr/bin/expect

set timeout 300
set monitor_host "192.168.50.212"
set server_host "192.168.50.210"
set client_host "192.168.50.211"
set test_file "/home/test/data/DryFire_v4_10.zip"

# Log file setup
log_file -a "snmp_dynamic_rates_results.log"
send_log "\n=== Starting Dynamic Rate Change Tests with SNMP Monitoring ===\n"
send_log "[exec date]\n"

# SNMP OIDs
set throughput_oid ".1.3.6.1.4.1.8072.1.3.2.3.1.2.19.115.115.115.111.110.101.99.116.111.114.45.116.104.114.111.117.103.104.112.117.116.1.0"
set connections_oid ".1.3.6.1.4.1.8072.1.3.2.3.1.2.21.115.115.115.111.110.101.99.116.111.114.45.99.111.110.110.101.99.116.105.111.110.115.1.0"
set latency_oid ".1.3.6.1.4.1.8072.1.3.2.3.1.2.17.115.115.115.111.110.101.99.116.111.114.45.108.97.116.101.110.99.121.1.0"

proc collect_metrics {duration interval} {
    global monitor_host throughput_oid connections_oid latency_oid
    set metrics {}
    set start_time [clock seconds]
    
    while {[clock seconds] - $start_time < $duration} {
        spawn snmpget -v2c -c public $monitor_host $throughput_oid $connections_oid $latency_oid
        expect {
            -re {(\d+:\d+).*?(\d+).*?(\d+\.\d+)} {
                set timestamp [clock seconds]
                lappend metrics [list $timestamp $expect_out(1,string) $expect_out(2,string) $expect_out(3,string)]
                send_log "."
            }
            timeout {
                send_log "T"
            }
        }
        sleep $interval
    }
    send_log "\n"
    return $metrics
}

proc set_rate_limit {rate} {
    global server_host
    spawn ssh test@$server_host
    expect "password:"
    send "test\r"
    expect "$ "
    send "sudo sssonector --set-rate-limit $rate\r"
    expect "password:"
    send "test\r"
    expect "$ "
    send "exit\r"
    expect eof
}

proc start_transfer {direction} {
    global server_host client_host test_file
    if {$direction eq "server-to-client"} {
        spawn ssh test@$client_host "nc $server_host 12345 > /dev/null"
    } else {
        spawn ssh test@$server_host "nc -l 12345 > /dev/null"
        expect "$ "
        spawn ssh test@$client_host "cat $test_file | nc $server_host 12345"
    }
}

proc test_gradual_changes {direction} {
    global test_file
    send_log "\n=== Testing gradual rate changes ($direction) ===\n"
    
    # Start with 5 Mbps and increment by 5 Mbps every 30 seconds up to 100 Mbps
    set current_rate 5
    set max_rate 100
    set step 5
    set interval 30
    
    # Start transfer
    start_transfer $direction
    
    # Initialize results
    set results {}
    
    while {$current_rate <= $max_rate} {
        send_log "\nSetting rate limit to $current_rate Mbps\n"
        set_rate_limit $current_rate
        
        # Collect metrics for this rate
        set metrics [collect_metrics $interval 1]
        
        # Process metrics
        set total_throughput 0
        set samples [llength $metrics]
        foreach metric $metrics {
            lassign $metric timestamp throughput connections latency
            lassign [split $throughput ":"] rx tx
            set total_throughput [expr {$total_throughput + ($tx - $rx)}]
        }
        set avg_throughput [expr {$total_throughput / $samples / 1024 / 1024 * 8}]
        
        # Check if throughput is within 10% of target (wider margin for transitions)
        set min_acceptable [expr {$current_rate * 0.90}]
        set max_acceptable [expr {$current_rate * 1.10}]
        
        if {$avg_throughput >= $min_acceptable && $avg_throughput <= $max_acceptable} {
            lappend results [list $current_rate 1]
            send_log "✓ Rate $current_rate Mbps: PASS (Measured: $avg_throughput Mbps)\n"
        } else {
            lappend results [list $current_rate 0]
            send_log "✗ Rate $current_rate Mbps: FAIL (Measured: $avg_throughput Mbps)\n"
        }
        
        set current_rate [expr {$current_rate + $step}]
    }
    
    return $results
}

proc test_rapid_changes {direction} {
    global test_file
    send_log "\n=== Testing rapid rate changes ($direction) ===\n"
    
    # Alternate between 10 and 100 Mbps every minute
    set rates {10 100}
    set interval 60
    set iterations 5
    
    # Start transfer
    start_transfer $direction
    
    # Initialize results
    set results {}
    
    for {set i 0} {$i < $iterations} {incr i} {
        foreach rate $rates {
            send_log "\nSetting rate limit to $rate Mbps\n"
            set_rate_limit $rate
            
            # Collect metrics
            set metrics [collect_metrics $interval 1]
            
            # Process metrics
            set total_throughput 0
            set samples [llength $metrics]
            foreach metric $metrics {
                lassign $metric timestamp throughput connections latency
                lassign [split $throughput ":"] rx tx
                set total_throughput [expr {$total_throughput + ($tx - $rx)}]
            }
            set avg_throughput [expr {$total_throughput / $samples / 1024 / 1024 * 8}]
            
            # Check if throughput is within 10% of target
            set min_acceptable [expr {$rate * 0.90}]
            set max_acceptable [expr {$rate * 1.10}]
            
            if {$avg_throughput >= $min_acceptable && $avg_throughput <= $max_acceptable} {
                lappend results [list $rate 1]
                send_log "✓ Rate $rate Mbps: PASS (Measured: $avg_throughput Mbps)\n"
            } else {
                lappend results [list $rate 0]
                send_log "✗ Rate $rate Mbps: FAIL (Measured: $avg_throughput Mbps)\n"
            }
        }
    }
    
    return $results
}

# Run tests in both directions
foreach direction {"server-to-client" "client-to-server"} {
    send_log "\n\n=== Testing $direction transfers ===\n"
    
    send_log "\nGradual Rate Changes:\n"
    set gradual_results [test_gradual_changes $direction]
    
    send_log "\nRapid Rate Changes:\n"
    set rapid_results [test_rapid_changes $direction]
    
    # Calculate success rates
    set total_tests [expr {[llength $gradual_results] + [llength $rapid_results]}]
    set passed_tests 0
    
    foreach result $gradual_results {
        lassign $result rate success
        if {$success} {
            incr passed_tests
        }
    }
    
    foreach result $rapid_results {
        lassign $result rate success
        if {$success} {
            incr passed_tests
        }
    }
    
    send_log "\n=== Results for $direction ===\n"
    send_log "Passed $passed_tests out of $total_tests tests\n"
}

send_log "\nTest completion time: [exec date]\n"

# Exit with success if all tests passed
if {$passed_tests == $total_tests} {
    exit 0
} else {
    exit 1
}
